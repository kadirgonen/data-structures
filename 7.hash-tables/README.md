<div class="h k ht hu hv"><div class="hw l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on twitter"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M20 5.34c-.67.41-1.4.7-2.18.87a3.45 3.45 0 0 0-5.02-.1 3.49 3.49 0 0 0-1.02 2.47c0 .28.03.54.07.8a9.91 9.91 0 0 1-7.17-3.66 3.9 3.9 0 0 0-.5 1.74 3.6 3.6 0 0 0 1.56 2.92 3.36 3.36 0 0 1-1.55-.44V10c0 1.67 1.2 3.08 2.8 3.42-.3.06-.6.1-.94.12l-.62-.06a3.5 3.5 0 0 0 3.24 2.43 7.34 7.34 0 0 1-4.36 1.49l-.81-.05a9.96 9.96 0 0 0 5.36 1.56c6.4 0 9.91-5.32 9.9-9.9v-.5c.69-.49 1.28-1.1 1.74-1.81-.63.3-1.3.48-2 .56A3.33 3.33 0 0 0 20 5.33" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="hw l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on facebook"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M19.75 12.04c0-4.3-3.47-7.79-7.75-7.79a7.77 7.77 0 0 0-5.9 12.84 7.77 7.77 0 0 0 4.69 2.63v-5.49h-1.9v-2.2h1.9v-1.62c0-1.88 1.14-2.9 2.8-2.9.8 0 1.49.06 1.69.08v1.97h-1.15c-.91 0-1.1.43-1.1 1.07v1.4h2.17l-.28 2.2h-1.88v5.52a7.77 7.77 0 0 0 6.7-7.71" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="hw l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on linkedin"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M19.75 5.39v13.22a1.14 1.14 0 0 1-1.14 1.14H5.39a1.14 1.14 0 0 1-1.14-1.14V5.39a1.14 1.14 0 0 1 1.14-1.14h13.22a1.14 1.14 0 0 1 1.14 1.14zM8.81 10.18H6.53v7.3H8.8v-7.3zM9 7.67a1.31 1.31 0 0 0-1.3-1.32h-.04a1.32 1.32 0 0 0 0 2.64A1.31 1.31 0 0 0 9 7.71v-.04zm8.46 5.37c0-2.2-1.4-3.05-2.78-3.05a2.6 2.6 0 0 0-2.3 1.18h-.07v-1h-2.14v7.3h2.28V13.6a1.51 1.51 0 0 1 1.36-1.63h.09c.72 0 1.26.45 1.26 1.6v3.91h2.28l.02-4.43z" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.57 14.67c0-.57.13-1.11.38-1.6l.02-.02v-.02l.02-.02c0-.02 0-.02.02-.02.12-.26.3-.52.57-.8L7.78 9v-.02l.01-.02c.44-.41.91-.7 1.44-.85a4.87 4.87 0 0 0-1.19 2.36A5.04 5.04 0 0 0 8 11.6L6.04 13.6c-.19.19-.32.4-.38.65a2 2 0 0 0 0 .9c.08.2.2.4.38.57l1.29 1.31c.27.28.62.42 1.03.42.42 0 .78-.14 1.06-.42l1.23-1.25.79-.78 1.15-1.16c.08-.09.19-.22.28-.4.1-.2.15-.42.15-.67 0-.16-.02-.3-.06-.45l-.02-.02v-.02l-.07-.14s0-.03-.04-.06l-.06-.13-.02-.02c0-.02 0-.03-.02-.05a.6.6 0 0 0-.14-.16l-.48-.5c0-.04.02-.1.04-.15l.06-.12 1.17-1.14.09-.09.56.57c.02.04.08.1.16.18l.05.04.03.06.04.05.03.04.04.06.1.14.02.02c0 .02.01.03.03.04l.1.2v.02c.1.16.2.38.3.68a1 1 0 0 1 .04.25 3.2 3.2 0 0 1 .02 1.33 3.49 3.49 0 0 1-.95 1.87l-.66.67-.97.97-1.56 1.57a3.4 3.4 0 0 1-2.47 1.02c-.97 0-1.8-.34-2.49-1.03l-1.3-1.3a3.55 3.55 0 0 1-1-2.51v-.01h-.02v.02zm5.39-3.43c0-.19.02-.4.07-.63.13-.74.44-1.37.95-1.87l.66-.67.97-.98 1.56-1.56c.68-.69 1.5-1.03 2.47-1.03.97 0 1.8.34 2.48 1.02l1.3 1.32a3.48 3.48 0 0 1 1 2.48c0 .58-.11 1.11-.37 1.6l-.02.02v.02l-.02.04c-.14.27-.35.54-.6.8L16.23 15l-.01.02-.01.02c-.44.42-.92.7-1.43.83a4.55 4.55 0 0 0 1.23-3.52L18 10.38c.18-.21.3-.42.35-.65a2.03 2.03 0 0 0-.01-.9 1.96 1.96 0 0 0-.36-.58l-1.3-1.3a1.49 1.49 0 0 0-1.06-.42c-.42 0-.77.14-1.06.4l-1.2 1.27-.8.8-1.16 1.15c-.08.08-.18.21-.29.4a1.66 1.66 0 0 0-.08 1.12l.02.03v.02l.06.14s.01.03.05.06l.06.13.02.02.01.02.01.02c.05.08.1.13.14.16l.47.5c0 .04-.02.09-.04.15l-.06.12-1.15 1.15-.1.08-.56-.56a2.3 2.3 0 0 0-.18-.19c-.02-.01-.02-.03-.02-.04l-.02-.02a.37.37 0 0 1-.1-.12c-.03-.03-.05-.04-.05-.06l-.1-.15-.02-.02-.02-.04-.08-.17v-.02a5.1 5.1 0 0 1-.28-.69 1.03 1.03 0 0 1-.04-.26c-.06-.23-.1-.46-.1-.7v.01z" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="hz o ao"></div></div><div class="cl ia"><div><div class="cj" aria-hidden="false"></div></div></div></div></div><div class="ib ic id j i d"><div class="fh l"></div><div class="ie l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on twitter"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M20 5.34c-.67.41-1.4.7-2.18.87a3.45 3.45 0 0 0-5.02-.1 3.49 3.49 0 0 0-1.02 2.47c0 .28.03.54.07.8a9.91 9.91 0 0 1-7.17-3.66 3.9 3.9 0 0 0-.5 1.74 3.6 3.6 0 0 0 1.56 2.92 3.36 3.36 0 0 1-1.55-.44V10c0 1.67 1.2 3.08 2.8 3.42-.3.06-.6.1-.94.12l-.62-.06a3.5 3.5 0 0 0 3.24 2.43 7.34 7.34 0 0 1-4.36 1.49l-.81-.05a9.96 9.96 0 0 0 5.36 1.56c6.4 0 9.91-5.32 9.9-9.9v-.5c.69-.49 1.28-1.1 1.74-1.81-.63.3-1.3.48-2 .56A3.33 3.33 0 0 0 20 5.33" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="ie l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on facebook"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M19.75 12.04c0-4.3-3.47-7.79-7.75-7.79a7.77 7.77 0 0 0-5.9 12.84 7.77 7.77 0 0 0 4.69 2.63v-5.49h-1.9v-2.2h1.9v-1.62c0-1.88 1.14-2.9 2.8-2.9.8 0 1.49.06 1.69.08v1.97h-1.15c-.91 0-1.1.43-1.1 1.07v1.4h2.17l-.28 2.2h-1.88v5.52a7.77 7.77 0 0 0 6.7-7.71" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="ie l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi" aria-label="Share on linkedin"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M19.75 5.39v13.22a1.14 1.14 0 0 1-1.14 1.14H5.39a1.14 1.14 0 0 1-1.14-1.14V5.39a1.14 1.14 0 0 1 1.14-1.14h13.22a1.14 1.14 0 0 1 1.14 1.14zM8.81 10.18H6.53v7.3H8.8v-7.3zM9 7.67a1.31 1.31 0 0 0-1.3-1.32h-.04a1.32 1.32 0 0 0 0 2.64A1.31 1.31 0 0 0 9 7.71v-.04zm8.46 5.37c0-2.2-1.4-3.05-2.78-3.05a2.6 2.6 0 0 0-2.3 1.18h-.07v-1h-2.14v7.3h2.28V13.6a1.51 1.51 0 0 1 1.36-1.63h.09c.72 0 1.26.45 1.26 1.6v3.91h2.28l.02-4.43z" fill="#A8A8A8"></path></svg></span></button></div></div></div><div class="l fp"><div><div class="cj" aria-hidden="false"><button class="au av aw ax ay az ba bb bc bd be bf bg bh bi"><span class="cj hx dy hy"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.57 14.67c0-.57.13-1.11.38-1.6l.02-.02v-.02l.02-.02c0-.02 0-.02.02-.02.12-.26.3-.52.57-.8L7.78 9v-.02l.01-.02c.44-.41.91-.7 1.44-.85a4.87 4.87 0 0 0-1.19 2.36A5.04 5.04 0 0 0 8 11.6L6.04 13.6c-.19.19-.32.4-.38.65a2 2 0 0 0 0 .9c.08.2.2.4.38.57l1.29 1.31c.27.28.62.42 1.03.42.42 0 .78-.14 1.06-.42l1.23-1.25.79-.78 1.15-1.16c.08-.09.19-.22.28-.4.1-.2.15-.42.15-.67 0-.16-.02-.3-.06-.45l-.02-.02v-.02l-.07-.14s0-.03-.04-.06l-.06-.13-.02-.02c0-.02 0-.03-.02-.05a.6.6 0 0 0-.14-.16l-.48-.5c0-.04.02-.1.04-.15l.06-.12 1.17-1.14.09-.09.56.57c.02.04.08.1.16.18l.05.04.03.06.04.05.03.04.04.06.1.14.02.02c0 .02.01.03.03.04l.1.2v.02c.1.16.2.38.3.68a1 1 0 0 1 .04.25 3.2 3.2 0 0 1 .02 1.33 3.49 3.49 0 0 1-.95 1.87l-.66.67-.97.97-1.56 1.57a3.4 3.4 0 0 1-2.47 1.02c-.97 0-1.8-.34-2.49-1.03l-1.3-1.3a3.55 3.55 0 0 1-1-2.51v-.01h-.02v.02zm5.39-3.43c0-.19.02-.4.07-.63.13-.74.44-1.37.95-1.87l.66-.67.97-.98 1.56-1.56c.68-.69 1.5-1.03 2.47-1.03.97 0 1.8.34 2.48 1.02l1.3 1.32a3.48 3.48 0 0 1 1 2.48c0 .58-.11 1.11-.37 1.6l-.02.02v.02l-.02.04c-.14.27-.35.54-.6.8L16.23 15l-.01.02-.01.02c-.44.42-.92.7-1.43.83a4.55 4.55 0 0 0 1.23-3.52L18 10.38c.18-.21.3-.42.35-.65a2.03 2.03 0 0 0-.01-.9 1.96 1.96 0 0 0-.36-.58l-1.3-1.3a1.49 1.49 0 0 0-1.06-.42c-.42 0-.77.14-1.06.4l-1.2 1.27-.8.8-1.16 1.15c-.08.08-.18.21-.29.4a1.66 1.66 0 0 0-.08 1.12l.02.03v.02l.06.14s.01.03.05.06l.06.13.02.02.01.02.01.02c.05.08.1.13.14.16l.47.5c0 .04-.02.09-.04.15l-.06.12-1.15 1.15-.1.08-.56-.56a2.3 2.3 0 0 0-.18-.19c-.02-.01-.02-.03-.02-.04l-.02-.02a.37.37 0 0 1-.1-.12c-.03-.03-.05-.04-.05-.06l-.1-.15-.02-.02-.02-.04-.08-.17v-.02a5.1 5.1 0 0 1-.28-.69 1.03 1.03 0 0 1-.04-.26c-.06-.23-.1-.46-.1-.7v.01z" fill="#A8A8A8"></path></svg></span></button></div></div></div></div></header><span class="l"></span><section><div><div class="fm as il im in io"></div><div class="ip iq ir is it"><div class=""><h1 id="4cd7" class="pw-post-title iu iv iw bn ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js fy">Hash Tables Implementation in Go</h1></div><div class=""><h2 id="e5b7" class="pw-subtitle-paragraph jt iv iw bn b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk co">The inner implementation. A story (for normal people).</h2></div><blockquote class="kl km kn"><p id="e665" class="ko kp kq kr b ks kt jx ku kv kw ka kx ky kz la lb lc ld le lf lg lh li lj lk ip fy"><strong class="kr ix">Note</strong>: Go maps are an implementation of hash tables, they are the same thing. So don’t be confused.</p></blockquote><p id="a54a" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">📜 <em class="kq">This article is based on Go 1.15</em></p><p id="763e" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">📜 <em class="kq">The Go code contains a lot of small details that were added over time. Don’t torture yourself for not understanding it right away. What you see is the result of 10+ years of evolution.</em></p><p id="0678" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Thanks very much to <a class="au lo" href="http://people.csail.mit.edu/randall/" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">Keith Randall</strong></a><strong class="kr ix"> </strong>for helping me understand this. <br/><strong class="kr ix">Keith</strong> is one of the Go team, and he is the original implementr of Go maps.</p><figure class="lq lr ls lt gv lu gj gk paragraph-image"><div role="button" tabindex="0" class="lv lw dq lx cf ly"><div class="gj gk lp"><img alt="" class="cf lz ma" src="https://miro.medium.com/max/1400/1*7FS7zDIY-IfpDqBGE4wNqQ.png" width="700" height="483" loading="lazy" role="presentation"/></div></div><figcaption class="mb bm gl gj gk mc md bn b bo bp co">This won’t make complete sense unless you watch the MIT lecture referenced below, but you can safely ignore it. Source: <a class="au lo" href="https://cdn.programiz.com/sites/tutorial2program/files/Hash-1_0.png" rel="noopener ugc nofollow" target="_blank">Programiz.com</a></figcaption></figure><p id="eaae" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy me"><span class="l mf mg mh mi mj mk ml mm mn dq">H</span>ash tables, or maps, are one of the handiest common data structures that comes with most programming languages. But did you ever tried to implement one?</p><p id="3914" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Go’s source code has a lot of interesting implementations, even in tasks that you may think it is standard and there are no more tweaks to add to make it better, like <a class="au lo" href="https://github.com/golang/go/blob/master/src/sort/sort.go" rel="noopener ugc nofollow" target="_blank">sorting</a>.</p><p id="97d2" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So as a way to push my knowledge a little bit further, I thought it is a good idea to take a look at a part like Go maps and see how the Go team has done it. At the end of the day, programming languages are one of the most interesting projects for any programmer, and they include the meat of computer science.</p><p id="d2cd" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><strong class="kr ix">So let’s Go</strong>…<br/><strong class="kr ix">Wait</strong>, here is something to cheer you up before we dive in 🐱</p><figure class="lq lr ls lt gv lu gj gk paragraph-image"><div class="gj gk mo"><img alt="" class="cf lz ma" src="https://miro.medium.com/max/500/1*03tF947uJ2jI4NCKXCNw4A.gif" width="250" height="370" loading="lazy" role="presentation"/></div><figcaption class="mb bm gl gj gk mc md bn b bo bp co">Hash tables and cats are best friends.</figcaption></figure></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><p id="c0cd" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">⏱ If you know what hash tables are, just skip this part.</p><h1 id="81b7" class="mw mx iw bn my mz na nb nc nd ne nf ng kc nh kd ni kf nj kg nk ki nl kj nm nn fy">What is a Hash Table?</h1><p id="e0f7" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">First I think I should tell you a little bit about <a class="au lo" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">Hash Tables</strong></a>.</p><p id="80a6" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So as you know, our programs are loaded in memory for the processor to run them. So what is the memory?</p><p id="f8c7" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">It is just a really boring series of boxes, that’s it, nothing fancy there. <br/>But when we code, we like to have some handy data structures to work with, but those data structures usually are more complicated than a series of boxes. <br/>So what we do?</p><p id="47a2" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">We do what programmers always do, we build a layer of abstraction over them to let us forget about the boxes, and just see it as we want to see it.</p><p id="ce24" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">And here comes the old, not very much used now, term <strong class="kr ix">Abstract Data Structure (ADT)</strong>. A Hash Table is an ADT, which simply means that it looks to you, the programmer, as a hash table, but it is represented in the memory as something else.</p><h2 id="0154" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">So what kind of ADT a hash table is?</h2><blockquote class="oh"><p id="3b89" class="oi oj iw bn ok ol om on oo op oq lk co">A Hash table is a data structure that represents data in the form of <strong class="ba">key-value</strong> pairs.</p></blockquote><p id="d19d" class="pw-post-body-paragraph ko kp iw kr b ks or jx ku kv os ka kx ll ot la lb lm ou le lf ln ov li lj lk ip fy">So we want to represent our data with keys, while each key holds a certain value. Kind of like this:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="981a" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">And we want to be able to do (at least) the following operations:</p><ul class=""><li id="ac61" class="oy oz iw kr b ks kt kv kw ll pa lm pb ln pc lk pd pe pf pg fy"><strong class="kr ix">Add</strong> a new key-value pair</li><li id="55e1" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">Get</strong> the value of a given key</li><li id="8bd1" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">Delete</strong> a key-value pair</li></ul><h2 id="5ade" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">So how could we achieve that?</h2><p id="e5dd" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">Since we will use an array as the underlying data structure, <strong class="kr ix">we would like to map the hash table keys to array indexes</strong>, then store the values into those indexes.</p><p id="c5f9" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">This mapping operation is called <strong class="kr ix">hashing</strong> <em class="kq">(hence the name hash table), </em>which includes many crazy methods invented by many crazy computer scientists to convert a string (could be something else) into a <em class="kq">practical</em> number to be used as an array index (or as something else in another case).</p><p id="c071" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So the data we presented earlier would be represented internally like this:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="41d6" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So when we add a key-value pair, we take the key, pass it to the hash function, then take the resulting number, use it as an index, and store the value at that index. And when we want to get a value for a given key, we do the same, except we return the value at the end, not storing any. You got the idea.</p><h2 id="b15b" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">So what are the complications that arise from this design?</h2><p id="175a" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">We have three main issues to deal with <em class="kq">(in the Go implementation we have more than those issues, like generic values — comes later in the article)</em>:</p><ul class=""><li id="8224" class="oy oz iw kr b ks kt kv kw ll pa lm pb ln pc lk pd pe pf pg fy">What if the hash function produced the same number for two different strings? (which is called a <strong class="kr ix"><em class="kq">collision</em></strong>)</li><li id="5b5e" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy">What if the numbers produced were too far from each other (2, and 1000 for example)? we would have too much wasted space in the underlying array.</li><li id="6737" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy">What if we filled all the array and wanted to add more key-value pairs?</li></ul><p id="7c61" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><strong class="kr ix">Now you see the core of the problem. </strong>🤯</p><p id="29fd" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">The first issue, <strong class="kr ix"><em class="kq">collisions</em></strong>, is handled by using a linked list <em class="kq">(this method is called </em><a class="au lo" href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix"><em class="kq">chaining</em></strong></a><em class="kq">, there are other methods like </em><a class="au lo" href="https://en.wikipedia.org/wiki/Open_addressing" rel="noopener ugc nofollow" target="_blank"><em class="kq">open addressing</em></a><em class="kq">)</em>. So we don’t save the value at its index right away. Instead, we save a linked list and append the values to it. So if two different keys collide with each other (produced the same hash result), they will get appended to the same linked list. And when we want to get any one of them, we will hash the key, get the index, then search the linked list for the right value.</p><p id="cd98" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">The second issue is handled in Go by not using the result of the hash function right away. Instead, we do some <a class="au lo" href="https://en.wikipedia.org/wiki/Bit_manipulation" rel="noopener ugc nofollow" target="_blank">bit manipulation</a> to get a number of the lowest bits (the ones from the right) and use that as an index.</p><p id="c25e" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">The third issue is handled by growing the underlying table, then rehashing all keys. That is called growing in Go, which is not covered in this article.</p><p id="7084" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">📺 There is also an awesome introduction to Hash Tables from MIT <a class="au lo" href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" rel="noopener ugc nofollow" target="_blank">here</a>.</p><p id="1b99" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So how does Go implements Hash Tables? Let’s dive in.</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h1 id="747f" class="mw mx iw bn my mz pm nb nc nd pn nf ng kc po kd ni kf pp kg nk ki pq kj nm nn fy">How does Go implement Hash Tables?</h1><p id="3753" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">So here is the interesting part. The main code we will explore is in this <a class="au lo" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/map.go" rel="noopener ugc nofollow" target="_blank">file</a>.</p><h2 id="f114" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">First, The Generics Fail</h2><p id="f3a1" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">Generics is a way to write code that deals with more than one type. <br/>And that is exactly what we want to do with maps, but Go doesn’t have generics, so how could Go implement maps then?</p><p id="3af1" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">We fake it, as <strong class="kr ix">Keith Randall </strong><a class="au lo" href="https://youtu.be/Tl7mi9QmLns?t=716" rel="noopener ugc nofollow" target="_blank">said</a>. So how we fake it? <br/>With some help from the compiler and the runtime, our heroes 🦸.</p><p id="d846" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">When you type any maps code, the compiler converts it to a call to the runtime, similar to this:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><ul class=""><li id="c7e3" class="oy oz iw kr b ks kt kv kw ll pa lm pb ln pc lk pd pe pf pg fy"><a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/type.go#L384" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">maptype</strong></a>: is a type descriptor <em class="kq">(struct that holds many type descriptors to be accurate, one for the key, one for the value, and some other things)</em>, which is just a meta-data about your key and value types.</li><li id="6aa8" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/map.go#L115" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">hmap</strong></a>: the map header <em class="kq">(we will talk more about it later)</em></li><li id="93bb" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">k</strong>: a pointer to the key you provided</li></ul><p id="dc95" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So why we need <strong class="kr ix">maptype</strong>? I will quote <a class="au lo" href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics" rel="noopener ugc nofollow" target="_blank">Dave Cheney</a> here:</p><blockquote class="kl km kn"><p id="f7be" class="ko kp kq kr b ks kt jx ku kv kw ka kx ky kz la lb lc ld le lf lg lh li lj lk ip fy">Why do we need a <code class="fn pr ps pt pu b">*maptype</code> if we already have a <code class="fn pr ps pt pu b">*hmap</code>? <code class="fn pr ps pt pu b">*maptype</code> is the special sauce that makes the generic <code class="fn pr ps pt pu b">*hmap</code> work for (almost) any combination of key and value types. There is a <code class="fn pr ps pt pu b">maptype</code> value for each unique map declaration in your program. There will be one that describes maps from <code class="fn pr ps pt pu b">string</code>s to <code class="fn pr ps pt pu b">int</code>s, from <code class="fn pr ps pt pu b">string</code>s to <code class="fn pr ps pt pu b">http.Header</code>s, and so on.</p><p id="7e5a" class="ko kp kq kr b ks kt jx ku kv kw ka kx ky kz la lb lc ld le lf lg lh li lj lk ip fy">Rather than having, as C++ has, a complete map <em class="iw">implementation</em> for each unique map declaration, the Go compiler creates a <code class="fn pr ps pt pu b">maptype</code> during compilation and uses that value when calling into the runtime’s map functions.</p></blockquote><p id="3475" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So here you go, the compiler creates <code class="fn pr ps pt pu b">maptype</code> for your specific map, and pass that to the runtime calls.<em class="kq"> </em>👌</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="64ea" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">Creation</h2><p id="88a7" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">When you create a map, the runtime creates a bunch of stuff for you and returns a pointer to what the language calls <a class="au lo" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/map.go#L115" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix"><em class="kq">map header</em></strong></a>. The map header is just a struct, nothing fancy about it. Here is how it looks like:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="1ea8" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><strong class="kr ix">At </strong><a class="au lo" href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/map.go#L303" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">creation</strong></a>, the important fields we have to fill are the following:</p><ul class=""><li id="d613" class="oy oz iw kr b ks kt kv kw ll pa lm pb ln pc lk pd pe pf pg fy"><strong class="kr ix"><em class="kq">B</em></strong>: <em class="kq">log_2</em> of the number of buckets</li><li id="3c90" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix"><em class="kq">hash0</em></strong>: a random seed. <em class="kq">It is how the Go runtime avoids hash collisions.</em></li><li id="9c42" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix"><em class="kq">buckets</em></strong>: the underlying array of buckets (actually a pointer to it)</li><li id="e704" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix"><em class="kq">extra</em></strong>: overflow buckets</li></ul><h2 id="f25b" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">What is B?</h2><p id="46e0" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">As I said it is <em class="kq">log_2</em> of the number of buckets. But why we need that here?</p><p id="3523" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Remember, we will take a string, hash it, then use that hash to determine the index in the underlying array.</p><p id="6453" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">But the hash usually won’t be in the range of the size of the array (remember, the second issue above). If the length of the underlying array is 8, and the hash function produced the number 1378 for a certain string, we have a problem. We can’t just expand the array and add the value there, we will waste too much space.</p><p id="6e6f" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><strong class="kr ix">So we need a way to make sure that the end result of the hashing process is in the range of the underlying array.</strong> And here comes the magic of <em class="kq">log_2.</em></p><p id="a951" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Let’s take a look at this table first</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="809e" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Can you see it? the number of bits we need to cut from the hash to be in the range of the underlying array equals <code class="fn pr ps pt pu b">ceil(log2(N))</code> (or just <code class="fn pr ps pt pu b">log2(N)</code> if we restricted the length of the array to be an exponential of 2, which what the Go code does).</p><p id="a0d9" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Here is how the <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L598" rel="noopener ugc nofollow" target="_blank">code</a> does it:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="920b" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><code class="fn pr ps pt pu b">x &amp; (1 &lt;&lt; n -1)</code> is a <a class="au lo" href="https://en.wikipedia.org/wiki/Bit_manipulation" rel="noopener ugc nofollow" target="_blank">bit manipulation</a> way to get the lowest <em class="kq">n</em> bits (the ones from the right) from <em class="kq">x</em>. You can use another way if you like.</p><p id="eaa9" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">In our case, the result will be 0010, which is 2 in decimal. And that is our index. 🥳🎉</p><p id="5884" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Play with it <a class="au lo" href="https://play.golang.org/p/vxERowyiRzf" rel="noopener ugc nofollow" target="_blank">here</a>.</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="afb2" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">Memory Allocation</h2><p id="4c86" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">As we said, when you create a map, Go calculates <strong class="kr ix"><em class="kq">B</em></strong>, and allocates memory for the underlying <strong class="kr ix"><em class="kq">buckets</em></strong> array.</p><p id="17ef" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">But the size of the array elements will differ between maps. And here comes <code class="fn pr ps pt pu b">maptype</code> again. As it has an internal representation for the bucket, it <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L362" rel="noopener ugc nofollow" target="_blank">uses</a> it to create an array of the right size.</p><p id="c6ac" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">So you can think of the data as the following:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="28d8" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">It is important to keep that representation in mind because as you look into the code and see the definition of <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L149" rel="noopener ugc nofollow" target="_blank">bmap</a>, you won’t find fields for the keys and values. But the code actually allocates memory for them, and <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L615" rel="noopener ugc nofollow" target="_blank">assigns</a> value to them using some fake pointer arithmetic.</p><p id="b661" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Let’s look at that <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L615" rel="noopener ugc nofollow" target="_blank">line</a> I referenced above, it is used on assignment to get a pointer to our element in an empty slot in our bucket:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><ul class=""><li id="619b" class="oy oz iw kr b ks kt kv kw ll pa lm pb ln pc lk pd pe pf pg fy"><strong class="kr ix">add</strong>: an internal function <em class="kq">(which may be </em><a class="au lo" href="https://github.com/golang/go/issues/40481" rel="noopener ugc nofollow" target="_blank"><em class="kq">exported</em></a><em class="kq"> later)</em> which does pointer arithmetic</li><li id="01cd" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">b</strong>: a pointer to <em class="kq">bmap</em></li><li id="5d15" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">dataOffset</strong>: the size of the <em class="kq">bmap</em> struct</li><li id="553a" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">bucketCnt</strong>: equals 8, which is the length of our bucket</li><li id="cf92" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">keysize</strong>: the size of the type of the keys of the map</li><li id="9649" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">i</strong>: our index inside the loop</li><li id="0d95" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">elemsize</strong>: the size of the type of the elements of the map</li></ul><p id="1bef" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">This basically says, take that pointer and add to it the size of the bucket struct, and the size of all our 8 keys, and the size of the preceding elements, then return it. And that would be the place of our current element.</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="9d68" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">Assignment</h2><p id="e9b8" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">To understand <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L571" rel="noopener ugc nofollow" target="_blank">assignment</a>, you have to know that <strong class="kr ix">Go doesn’t use linked lists</strong> for chaining, as usual, instead, it uses just another array.</p><p id="6759" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">If you use linked lists, you would get the index of the bucket containing the linked list, get the linked list, loop over it to check if the value already exists, if it does exist then you update it, if it doesn’t you just append it to the list.</p><p id="2e70" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Go does something a little bit different. As I said it uses just an array of size 8, and uses the highest bits (the ones from the left) to decide where to put the value inside the array. <strong class="kr ix">But not in the way it uses the lowest bits to decide the index of the bucket.</strong></p><p id="f8ed" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy"><a class="au lo" href="https://play.golang.org/p/AzOXji_gKcO" rel="noopener ugc nofollow" target="_blank">This is how Go gets the highest bits</a> (which Go code calls <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L194" rel="noopener ugc nofollow" target="_blank"><em class="kq">tophash</em></a>).</p><p id="f39f" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">This is important to understand. If the index of the bucket is 3, and the highest bits equal 5 in decimal, Go doesn’t do the following:</p><figure class="lq lr ls lt gv lu"><div class="m l dq"><div class="ow ox l"></div></div></figure><p id="a7af" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Instead, <strong class="kr ix">Go uses any empty slot in the array and puts the value there.</strong><br/>On assignment, it <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L608" rel="noopener ugc nofollow" target="_blank">loops</a> over the array checking if an array element equals the highest bits, if none exists, it just adds the value to an empty slot (the last one in the loop actually), if it found a match then it just updates it.</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="8af6" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">Load Factor</h2><p id="e0e8" class="pw-post-body-paragraph ko kp iw kr b ks no jx ku kv np ka kx ll nq la lb lm nr le lf ln ns li lj lk ip fy">I didn’t mention a key detail about hash tables and left it to the end of the article, which is the load factor.</p><blockquote class="oh"><p id="ed0c" class="oi oj iw bn ok ol om on oo op oq lk co">The load factor is the average number of key-value pairs per bucket. It is used as a measure of how full the hash table is allowed to get before its capacity is automatically increased. And it defines the balance between access time and space.</p></blockquote><p id="0e98" class="pw-post-body-paragraph ko kp iw kr b ks or jx ku kv os ka kx ll ot la lb lm ou le lf ln ov li lj lk ip fy"><strong class="kr ix">What does all of that mean?<br/></strong>The Load Factor is a typical trade-off between time and space, that arise whenever you design a hash table. It is a constant that the language chooses and uses it to decide if it should grow the table or not. <strong class="kr ix">So the hash table is not <em class="kq">only</em> grown when it became full</strong>, but if the total number of key-value pairs over the number of buckets go beyond the load factor we trigger growing.</p><p id="ec10" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">You can use a larger load factor to save space, but at more elements per bucket and therefore worse access time. You can reduce the load factor to improve access time, but the hash table will be larger.</p><p id="b3ac" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">Go uses 6.5 as load factor, read about it <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L33" rel="noopener ugc nofollow" target="_blank">here</a>. 7.5 or 0.75 is commonly used.<br/>Go then has a <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L1070" rel="noopener ugc nofollow" target="_blank">function</a> that reports if we hit the load factor or not.</p><p id="94b8" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">And you can see that it uses it at <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L318" rel="noopener ugc nofollow" target="_blank">creation</a> <em class="kq">(note: hint is the optional map capacity that Go allows you to define when creating a map)</em>, and at <a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L647" rel="noopener ugc nofollow" target="_blank">assignment</a>.</p></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="743e" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">Remember</h2><ul class=""><li id="02ee" class="oy oz iw kr b ks no kv np ll pv lm pw ln px lk pd pe pf pg fy"><strong class="kr ix">Lowest bits</strong> <em class="kq">(the ones from the right)</em></li><li id="dca8" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">Highest bits</strong> <em class="kq">(the ones from the left, also called the most significant bits or MSB)</em></li><li id="7daa" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L149" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">bmap</strong></a>: the map bucket</li><li id="9d04" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/map.go#L115" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">hmap</strong></a>: the map header</li><li id="9e4d" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><strong class="kr ix">Load Factor</strong>: the allowed average number of key-value pairs per bucket</li><li id="9865" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://github.com/golang/go/blob/b4c8b67adcd39da54f210bef5c201b1df8124d73/src/runtime/stubs.go#L11" rel="noopener ugc nofollow" target="_blank"><strong class="kr ix">add</strong></a>: an internal function that does pointer arithmetic</li></ul></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><h2 id="e954" class="nt mx iw bn my nu nv nw nc nx ny nz ng ll oa ob ni lm oc od nk ln oe of nm og fy">References</h2><ul class=""><li id="011d" class="oy oz iw kr b ks no kv np ll pv lm pw ln px lk pd pe pf pg fy"><a class="au lo" href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" rel="noopener ugc nofollow" target="_blank">Hashing with Chaining | MIT</a></li><li id="fcd9" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://algs4.cs.princeton.edu/34hash/" rel="noopener ugc nofollow" target="_blank">Hash Tables | Algorithms</a></li><li id="1665" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://www.youtube.com/watch?v=Tl7mi9QmLns" rel="noopener ugc nofollow" target="_blank">GopherCon 2016: Keith Randall — Inside the Map Implementation</a> [<a class="au lo" href="https://docs.google.com/presentation/d/1CxamWsvHReswNZc7N2HMV7WPFqS8pvlPVZcDegdC_T4/edit#slide=id.p" rel="noopener ugc nofollow" target="_blank">slides</a>]</li><li id="a9d3" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics" rel="noopener ugc nofollow" target="_blank">How the Go runtime implements maps efficiently (without generics)</a></li><li id="b17d" class="oy oz iw kr b ks ph kv pi ll pj lm pk ln pl lk pd pe pf pg fy"><a class="au lo" href="https://sourcegraph.com/github.com/golang/go@b4c8b67adcd39da54f210bef5c201b1df8124d73/-/blob/src/runtime/map.go" rel="noopener ugc nofollow" target="_blank">Sourcegraph: runtime/map.go</a> (Very handy for browsing the code online)</li></ul></div><div class="o dz mp mq ib mr" role="separator"><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu mv"></span><span class="ms fj cj mt mu"></span></div><div class="ip iq ir is it"><p id="706d" class="pw-post-body-paragraph ko kp iw kr b ks kt jx ku kv kw ka kx ll kz la lb lm ld le lf ln lh li lj lk ip fy">
